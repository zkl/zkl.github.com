---
layout: post
title: "Windows函数的调用约定"
description: ""
category: 
tags: 
---

{% include JB/setup %}
# Windows函数的调用约定
---


*关于函数的调用规则（调用约定），大多数时候是不需要了解的，但是如果需要跨语言的编程，比如VC写的dll要delphi调用，则需要了解。*

<!--break-->

Microsoft的vc默认的是 \_\_cdecl方式，而windows
API则是\_\_stdcall，如果用vc开发dll给其他语言用，则应该指定\_\_stdcall方式。堆栈由谁清除这个很重要，如果是要写汇编函数给C调用，一定要小心堆栈的清除工作，如果是\_\_cdecl方式的函数，则函数本身（如果不用汇编写）则不需要关心保存参数的堆栈的清除，但是如果是\_\_stdcall的规则，一定要在函数退出(ret)前恢复堆栈。


### 1. \_\_cdecl

所谓的C调用规则。按从右至左的顺序压参数入栈，由调用者把参数弹出栈。切记：对于传送参数的内存栈是由调用者来维护的。返回值在EAX中因此，对于象printf这样变参数的函数必须用这种规则。编译器在编译的时候对这种调用规则的函数生成修饰名的饿时候，仅在输出函数名前加上一个下划线前缀，格式为\_functionname。 

### 2. \_\_stdcall 

按从右至左的顺序压参数入栈，由被调用者把参数弹出栈。\__stdcall是Pascal程序的缺省调用方式，通常用于Win32 Api中，切记：函数自己在退出时清空堆栈，返回值在EAX中。

\_\_stdcall调用约定在输出函数名前加上一个下划线前缀，后面加上一个“@”符号和其参数的字节数，格式为\_functionname@number。如函数int
func(int a, double b)的修饰名是\_func@12。

### 3. \_\_fastcall

\_\_fastcall调用的主要特点就是快，因为它是通过寄存器来传送参数的（实际上，它用ECX和EDX传送前两个双字（DWORD）或更小的参数，剩下的参数仍旧自右向左压栈传送，被调用的函数在返回前清理传送参数的内存栈）。\_\_fastcall调用约定在输出函数名前加上一个“@”符号，后面也是一个“@”符号和其参数的字节数，格式为@functionname@number。这个和__stdcall很象，唯一差别就是头两个参数通过寄存器传送。注意通过寄存器传送的两个参数是从左向右的，即第一个参数进ECX，第2个进EDX，其他参数是从右向左的入stack。返回仍然通过EAX.

### 4. \_\_pascal

这种规则从左向右传递参数，通过EAX返回，堆栈由被调用者清除

### 5. \_\_thiscall

仅仅应用于"C++"成员函数。this指针存放于CX寄存器，参数从右到左压。thiscall不是关键词，因此不能被程序员指定 

调用约定可以通过工程设置：Setting.../C/C++ /Code
Generation项进行选择，缺省状态为\_\_cdecl。

## 名字修饰约定

** 1、修饰名(Decoration name)：**
"C"或者"C++"函数在内部（编译和链接）通过修饰名识别

** 2、C编译时函数名修饰约定规则：**
\_\_stdcall调用约定在输出函数名前加上一个下划线前缀，后面加上一个"@"符号和其参数的字节数，格式为\_functionname@number,例如
： function(int a, int b)，其修饰名为：\_function@8

\_\_cdecl调用约定仅在输出函数名前加上一个下划线前缀，格式为\_functionname。
\_\_fastcall调用约定在输出函数名前加上一个"@"符号，后面也是一个"@"符号和其参数的字节数，格式为@functionname@number。

** 3、C++编译时函数名修饰约定规则： **

\_\_stdcall调用约定：  

1. 以"?"标识函数名的开始，后跟函数名；  

2. 函数名后面以"@@YG"标识参数表的开始，后跟参数表；  

3. 参数表以代号表示：   
	+ D  -- char，
	+ E  -- unsigned char，
	+ F  -- short，
	+ H  -- int，
	+ I  -- unsigned int，
	+ J  -- long，
	+ K  -- unsigned long，
	+ M  -- float，
	+ N  -- double，
	+ _N -- bool，
	+ PA -- 表示指针，后面的代号表明指针类型，如果相同类型的指针连续出现，以"0"代替，一个"0"代表一次重复；

4. 参数表的第一项为该函数的返回值类型，其后依次为参数的数据类型,指针标识在其所指数据类型前；

5. 参数表后以"@Z"标识整个名字的结束，如果该函数无参数，则以"Z"标识结束。其格式为"?functionname@@YG*****@Z"或"?functionname@@YG*XZ"，例如

          int Test1(char *var1,unsigned long) // "?Test1@@YGHPADK@Z"
          void Test2()                        // "?Test2@@YGXXZ"

   \_\_cdecl调用约定规则同上面的\_\_stdcall调用约定，只是参数表的开始标识由上面的"@@YG"变为"@@YA"。\_\_fastcall调用约定：规则同上面的\_\_stdcall调用约定，只是参数表的开始标识由上面的"@@YG"变为"@@YI"。VC++对函数的省缺声明是"\_\_cedcl",将只能被C/C++调用.

## 注意
1.\_beginthread需要\_\_cdecl的线程函数地址，\_beginthreadex和CreateThread需要\_\_stdcall的线程函数地址。

2. 一般WIN32的函数都是\_\_stdcall。而且在Windef.h中有如下的定义：

        #define CALLBACK __stdcall
        #define WINAPI　 __stdcall

        extern "C" _declspec(dllexport) int __cdecl Add(int a, int b);
        typedef int (__cdecl*FunPointer)(int a, int b);
        
   修饰符的书写顺序如上。

4. extern "C"的作用：

  如果Add(int a, int b)是在c语言编译器编译，而在c++文件使用，则需要在c++文件中声明： extern "C" Add(int a, int b)， 因为c编译器和c++编译器对函数名的解释不一样（c++编译器解释函数名的时候要考虑函数参数，这样是了方便函数重载，而在c语言中不存在函数重载的问题），使用extern "C"，实质就是告诉c++编译器，该函数是c库里面的函数。如果不使用extern "C"则会出现链接错误。 一般象如下使用：
    
        #ifdef _cplusplus 
        #define ETERN_C extern "C"
        #else
        #define EXTERN_C extern
        #endif
        
        #ifdef _cplusplus 
        extern "C"{
        #endif 
        EXTERN_C int func(int a, int b); 
        #ifdef _cplusplus 
        } 
        #endif

5. MFC提供了一些宏，可以使用AFX_EXT_CLASS来代替\_\_declspec(DLLexport)，并修饰类名，从而导出类，AFX_API_EXPORT来修饰函数，AFX_DATA_EXPORT来修饰变量

        AFX_CLASS_IMPORT：__declspec(DLLexport)
        AFX_API_IMPORT：__declspec(DLLexport)
        AFX_DATA_IMPORT：__declspec(DLLexport)
        AFX_CLASS_EXPORT：__declspec(DLLexport)
        AFX_API_EXPORT：__declspec(DLLexport)
        AFX_DATA_EXPORT：__declspec(DLLexport)
        
        AFX_EXT_CLASS：
        
        #ifdef _AFXEXT 
        AFX_CLASS_EXPORT
        #else
        AFX_CLASS_IMPORT

6. DLLMain负责初始化(Initialization)和结束(Termination)工作，每当一个新的进程或者该进程的新的线程访问DLL时，或者访问DLL的每一个进程或者线程不再使用DLL或者结束时，都会调用DLLMain。但是，使用TerminateProcess或TerminateThread结束进程或者线程，不会调用DLLMain。

7. 一个DLL在内存中只有一个实例
    DLL程序和调用其输出函数的程序的关系：
 1. DLL与进程、线程之间的关系
        - DLL模块被映射到调用它的进程的虚拟地址空间。
        - DLL使用的内存从调用进程的虚拟地址空间分配，只能被该进程的线程所访问。
        - DLL的句柄可以被调用进程使用；调用进程的句柄可以被DLL使用。
        - DLLDLL可以有自己的数据段，但没有自己的堆栈，使用调用进程的栈，与调用它的应用程序相同的堆栈模式。

 2. 关于共享数据段

    DLL定义的全局变量可以被调用进程访问；DLL可以访问调用进程的全局数据。使用同一DLL的每一个进程都有自己的DLL全局变量实例。如果多个线程并发访问同一变量，则需要使用同步机制；对一个DLL的变量，如果希望每个使用DLL的线程都有自己的值，则应该使用线程局部存储(TLS，Thread Local Strorage)。

